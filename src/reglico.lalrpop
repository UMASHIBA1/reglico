grammar;
use crate::ast::ast::{Ident, Opcode, Types, Expr, ExprStmt, CallExpr, Operation, VariableDeclaration, FuncArg,  Func, ReturnStmt, Stmt};

pub Program = {
    Stmt*
}

Stmt: Stmt = {
    ConstAssignment => Stmt::VariableDeclaration(<>),
    ExprStmt => Stmt::ExprStmt(<>),
    Func => Stmt::Func(<>),
}

ExprStmt: ExprStmt = {
    <expr: Expr> ";" => ExprStmt::new(expr),
}

ConstAssignment: VariableDeclaration = {
    "const" <ident: IdentExpr> "=" <value: Expr> ";" => VariableDeclaration::new(ident, None, Some(value)),
    "const" <ident: IdentExpr> ":" <type_name: Types> "=" <value: Expr> ";" =>  VariableDeclaration::new(ident, Some(type_name), Some(value)),
}

IdentExpr: Ident = {
    r"[a-zA-Z_][a-zA-Z0-9_]*" => Ident::new(<>.to_string())
}

Types: Types = {
    "number" => Types::NumberType,
}

Expr: Expr = {
    <left: Term> <op: Opcode> <right: Term> => Expr::Op(Operation::new(left, op, right)),
    Term,
}

Opcode: Opcode = {
    "+" => Opcode::Add,
}

Term: Expr = {
    Num => Expr::num_new(<>),
    IdentExpr => Expr::ident_new(<>),
    CallExpr => Expr::Call(<>),
    "(" <Expr> ")",
}

Num: i32 = {
   r"[1-9][0-9]*" => <>.parse().unwrap(),
   r"0" => 0
}

CallExpr: CallExpr = {
    <ident: IdentExpr> "(" <args: CommaSeparate<Expr>> ")" => CallExpr::new(ident, args)
}

Func: Func = {
    "fn" <name: IdentExpr> "(" <args: CommaSeparate<FuncArg>> ")" "{" <stmts: Stmt*> <return_stmt: ReturnStmt?> "}" => Func::new(name, args, stmts, return_stmt)
}

FuncArg: FuncArg = {
    <ident: IdentExpr> ":" <arg_type: Types> => FuncArg::new(ident, arg_type),
}

ReturnStmt: ReturnStmt = {
    "return" <expr: Expr> ";" => ReturnStmt::new(expr),
}

CommaSeparate<T>: Vec<T> = { // (1)
    <mut v:(<T> ",")*> <e:T?> => match e { // (2)
        None => v,
        Some(e) => {
            v.push(e);
            v
        }
    }
};

