grammar;
use super::ast::{Opcode, Types, Expr, ExprStmt, VariableDeclaration, FuncArg, Func, Stmt};

pub Program = {
    Stmt*
}

pub Stmt: Stmt = {
    ConstAssignment => Stmt::VariableDeclaration(<>),
    ExprStmt => Stmt::ExprStmt(<>),
    Func => Stmt::Func(<>),
}

ExprStmt: ExprStmt = {
    <expr: Expr> ";" => ExprStmt { expr: expr },
}

ConstAssignment: VariableDeclaration = {
    "const" <ident: IdentExpr> "=" <value: Expr> ";" => VariableDeclaration {name: ident, typeName: None, value: Some(value)},
    "const" <ident: IdentExpr> ":" <typeName: Types> "=" <value: Expr> ";" =>  VariableDeclaration {name: ident, typeName: Some(typeName), value: Some(value)},
}

IdentExpr: String = {
    r"[a-zA-Z_][a-zA-Z0-9_]*" => <>.to_string()
}

Types: Types = {
    "number" => Types::NumberType,
}

Expr: Expr = {
    OpExpr,
    Term,
}

OpExpr: Expr = {
    <left: Expr> <op: Opcode> <right: Term> => Expr::Op(Box::new(left), op, Box::new(right))
}

Opcode: Opcode = {
    "+" => Opcode::Add,
}

Term: Expr = {
    Num => Expr::Number(<>),
    "(" <Expr> ")"
}

Num: i32 = {
   r"[1-9][0-9]*" => <>.parse().unwrap(),
   r"0" => 0
}

FuncArg: FuncArg = {
    <ident: IdentExpr> ":" <argType: Types> => FuncArg {name: ident, argType: argType},
}

Func: Func = {
    "fn" <name: IdentExpr> "(" <args: CommaSeparate<FuncArg>> ")" "{" <stmts: Stmt*> "}" => Func { name: name, args: args, stmts: stmts }
}

CommaSeparate<T>: Vec<T> = { // (1)
    <mut v:(<T> ",")*> <e:T?> => match e { // (2)
        None => v,
        Some(e) => {
            v.push(e);
            v
        }
    }
};

