grammar;
use super::ast::{Ident, Opcode, Types, Expr, ExprStmt, CallExpr, Operation, VariableDeclaration, FuncArg,  Func, ReturnStmt, Stmt};

pub Program = {
    Stmt*
}

pub Stmt: Stmt = {
    ConstAssignment => Stmt::VariableDeclaration(<>),
    ExprStmt => Stmt::ExprStmt(<>),
    Func => Stmt::Func(<>),
}

ExprStmt: ExprStmt = {
    <expr: Expr> ";" => ExprStmt { expr: expr },
}

ConstAssignment: VariableDeclaration = {
    "const" <ident: IdentExpr> "=" <value: Expr> ";" => VariableDeclaration {name: ident, typeName: None, value: Some(value)},
    "const" <ident: IdentExpr> ":" <typeName: Types> "=" <value: Expr> ";" =>  VariableDeclaration {name: ident, typeName: Some(typeName), value: Some(value)},
}

IdentExpr: Ident = {
    r"[a-zA-Z_][a-zA-Z0-9_]*" => Ident::new(<>.to_string())
}

Types: Types = {
    "number" => Types::NumberType,
}

Expr: Expr = {
    <left: Term> <op: Opcode> <right: Term> => Expr::Op(Operation::new(left, op, right)),
    Term,
}

Opcode: Opcode = {
    "+" => Opcode::Add,
}

Term: Expr = {
    Num => Expr::num_new(<>),
    IdentExpr => Expr::ident_new(<>),
    CallExpr => Expr::Call(<>),
    "(" <Expr> ")",
}

Num: i32 = {
   r"[1-9][0-9]*" => <>.parse().unwrap(),
   r"0" => 0
}

CallExpr: CallExpr = {
    <ident: IdentExpr> "(" <args: CommaSeparate<Expr>> ")" => CallExpr::new(ident, args)
}

Func: Func = {
    "fn" <name: IdentExpr> "(" <args: CommaSeparate<FuncArg>> ")" "{" <mut stmts: Stmt*> <returnStmt: ReturnStmt?> "}" => Func { name: name, args: args, stmts: stmts, returnStmt: returnStmt}
}

FuncArg: FuncArg = {
    <ident: IdentExpr> ":" <argType: Types> => FuncArg {name: ident, argType: argType},
}

ReturnStmt: ReturnStmt = {
    "return" <expr: Expr> ";" => ReturnStmt {expr: expr},
}

CommaSeparate<T>: Vec<T> = { // (1)
    <mut v:(<T> ",")*> <e:T?> => match e { // (2)
        None => v,
        Some(e) => {
            v.push(e);
            v
        }
    }
};

